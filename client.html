<!DOCTYPE html>
<html lang="pt">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Meu Primeiro Jogo Multiplayer</title>
	<style>
		#screen {
			border: 10px solid #ccc;
			image-rendering: pixelated;
			image-rendering: crisp-edges;
			image-rendering: -moz-crisp-edges;
			width: 400px;
			height: 400px;
		}
	</style>
</head>

<body>
	<canvas id="screen" width="10" height="10"></canvas>

	<script>
		const screen = document.getElementById("screen");
      const context = screen.getContext("2d");

      // CAMADA DE LOGICA, DADOS = JOGO

      // Factory Pattern - isolando a camada do Jogo
      function createGame() {
        const state = {
          fruits: {
            fruit1: { x: 3, y: 1 },
          },
          players: {
            player1: { x: 1, y: 1 },
            player2: { x: 9, y: 9 },
          },
        };

        function movePlayer(command) {
          console.log(`Moving ${command.playerId} with ${command.keyPressed}`);

          const keyPressed = command.keyPressed;
          const player = state.players[command.playerId];

          if (keyPressed === "ArrowUp" && player.y - 1 >= 0) {
            console.log("Up");
            player.y = player.y - 1;
            return;
          }

          if (keyPressed === "ArrowRight" && player.x + 1 < screen.width) {
            console.log("Right");
            player.x = player.x + 1;
            return;
          }

          if (keyPressed === "ArrowDown" && player.y + 1 < screen.height) {
            console.log("Down");
            player.y = player.y + 1;
            return;
          }

          if (keyPressed === "ArrowLeft" && player.x > 0) {
            console.log("Left");
            player.x = player.x - 1;
            return;
          }
        }

        // Retornar o objeto Jogo.
        // Externalizando método ou funcionalidade mover jogador.
        return {
          movePlayer,
          state,
        };
      }

      const game = createGame();

      // Selecionar o jogador
      const currentPlayerId = window.prompt(
        "Digite o jogador:",
        Object.keys(game.state.players)[0]
      );

      const keyboardListener = createKeyboardListener();

      // CAMADA DE INPUT - ACAO DO JOGADOR
      // Factory Pattern - isolando a camada de INPUT
      function createKeyboardListener() {
          // Observer Pattern - createKeyboardListener passa a ser um Subject
          observers: [] // Aqui vai ter o game (em runtime e não mais estaticamente acoplado)

          function subscribe(observerFunction) {
              observers.push(observerFunction)
          }

          function notifyAll(command) {
              console.log(`Notifying ${observers.length} observers`)

              for(const observerFunction of observers) {
                  observerFunction(command)
              }
          }
        document.addEventLitener("keydown", handleKeyDown);

        function handleKeyDown(event) {
          const command = {
            playerId: "player1",
            keyPressed: event.key,
          };

          //game.movePlayer(command);
          notifyAll(command)
          // o objetivo com o Observer Pattern foi remover o acomplamento com game (camada de jogo)
        }
      }

      // Selecionar o jogador
      const currentPlayerId = window.prompt("Digite o jogador:", "player1");

      renderScreen();

      // CAMADA DE APRESENTACAO

      function renderScreen() {
        // Limpa a tela ou inicializa a tela
        context.fillStyle = "white";
        context.clearRect(0, 0, 10, 10);

        // Desenha todos os jogadores com o estado atual
        for (playerId in game.state.players) {
          const player = game.state.players[playerId];
          context.fillStyle = "black";
          context.fillRect(player.x, player.y, 1, 1);
        }

        // Desenha todas as frutas com o estado atual
        for (fruitId in game.state.fruits) {
          const fruit = game.state.fruits[fruitId];
          context.fillStyle = "green";
          context.fillRect(fruit.x, fruit.y, 1, 1);
        }

        // chama a funcao de desenhar a tela recursivamente
        requestAnimationFrame(renderScreen);
      }
	</script>
</body>

</html>